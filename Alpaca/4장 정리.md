## 4장 설계 품질과 트레이드 오프

- 97
  - 책임 주도 설계라는 이름에서 알 수 있는 것처럼 역할, 책임, 협력 중에서 가장 중요한 것은 책임. 이 책임이 제대로 할당되어야지만 원활한 협력이 이루어지고 책임의 집합인 역할 또한 제대로 정립될 것이다.
  - 훌륭한 설계란 합리적인 비용 안에서 변경을 수용할 수 있는 구조를 만드는 것. 이를 위해 응집도를 높이고 결합도를 낮춰야 함.

### 1. 데이터 중심의 영화 예매 시스템

- 98
  - 데이터 중심의 관점은 객체의 상태에 초점을 맞추고 책임 중심의 관점은 객체의 행동에 초점을 맞춘다.
  - **객체의 상태는 구현에 속하며** 이는 불안정하고 변하기가 쉬움. 상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스에 스며들게 되어 캡슐화의 원칙이 무너진다. 따라서 상태가 변경될 경우 인터페이스가 변경되어 이 인터페이스에 의존하는 객체들에게 그 파장이 퍼져 나가게 되어 변경에 취약할 수밖에 없다.
  - **객체의 책임은 인터페이스에 속하며** 책임을 수행하는 데 필요한 상태를 캡슐화함으로써 구현 변경에 따른 파장이 외부로 나가지 않도록 할 수 있다.
- 100
  - **인스턴스 변수와 인스턴스의 종류에 따라 배타적으로 사용될 인스턴스 변수를 하나의 클래스 안에 포함**시키는 방식은 데이터 중심의 설계 안에서 흔히 볼 수 있는 패턴이다.
    - 사용되지도 않을 변수들을 포함시키는 것 => 응집도가 낮음

### 2. 설계 트레이드오프

#### 캡슐화

- 109
  - 변경될 가능성이 높은 부분을 **구현**, 상대적으로 안정적인 부분을 **인터페이스** 라고 부른다.
  - 객체를 설계하기 위한 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 **외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것**이다.
    - 구현 부분은 변경 가능성이 많이 때문에 외부에서 인터페이스에 의존하도록 하여 변경의 비용을 줄이도록 하는 것.

#### 응집도와 결합도

응집도와 결합도는 변경과 관련된 것. 높은 응집도와 낮은 결합도를 가진 설계를 추구하는 이유는 설계를 변경하기 쉽게 만들기 때문.

##### 응집도

- 변경의 관점에서 응집도란 **변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도** 로 측정
  - 하나의 변경이 모듈 전체의 변경을 가져온다면 응집도가 높은 것이지만 일부의 변경만 일어난다면 응집되어 있지 않은 것
- 변경을 하기 위해 하나의 모듈에서만 작업이 가능하다면 변경의 비용이 훨씬 작을 것. 하지만 응집되어 있지 않아 여러 모듈을 변경해야 한다면 비용이 훨씬 커질 것.

##### 결합도

- 결합도는 **한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도** 로 측정
- 모듈의 내부 구현을 변경했을 때 다른 모듈에 영향을 미친다면 결합도가 높다고 표현하지만 퍼블릭 인터페이스를 수정했을 때만 영향을 미치는 경우는 결합도가 낮다고 표현.
  - '인터페이스에 대해 프로그래밍하라'

마지막으로 캡슐화의 정도가 높을수록 응집도가 높아지고 모듈 사이의 결합도는 낮아지게 됨. 그러니 먼저 캡슐화를 고민!

### 3. 데이터 중심의 영화 예매 시스템의 문제점

#### 캡슐화 위반

- 114
  - 설계할 때 협력에 관해 고민하지 않으면 캡슐화를 위반하는 과도한 접근자와 수정자를 가지게 되는 경향이 있다.
  - 객체가 사용될 문맥을 잘 알지 못하기 때문에 어떤 상황에서도 사용될 수 있게 추가하게 됨

#### 높은 결합도

- 115
  - 결합도 측면에서 데이터 중심 설계가 가지는 또 다른 단점은 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체 안에 집중되기 때문에 **하나의 제어 객체가 다수의 데이터 객체에 강하게 결합**된다는 것이다.
    - 하나의 데이터 객체의 구현이 변경되었을 경우 다른 데이터 객체 또한 변경이 이루어져야 하기에 유연하지 못함.

#### 낮은 응집도

- 116
  - 어떤 코드를 수정한 후에 아무런 상관도 없던 코드에 문제가 발생하는 것은 모듈의 응집도가 낮을 때 발생하는 대표적인 증상
    - 어떤 열거형의 case를 추가하면 해당 타입을 사용하여 제어 로직이 들어가 있는 곳에서는 변경이 모두 일어날 수밖에 없다. 이는 응집도가 낮다는 증거.

### 4. 자율적인 객체를 향해

#### 캡슐화를 지켜라

- 119
  - 코드 중복과 변경에 취약하다는 단점을 단적으로 코드를 통해 보여주고 있다.

#### 스스로 자신의 데이터를 책임지는 객체

- 120
  - 객체를 설계할 때 "이 객체가 어떤 데이터를 포함해야 하는가?"라는 질문은 다음과 같은 두 개의 개별적인 질문으로 분리해야 한다.
    - 이 객체가 어떤 데이터를 포함해야 하는가?
    - 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?
- 123
  - 코드를 보면서 느낀 점
    - `Movie` 객체에서 할인 금액을 반환하는 세 메서드에서 설계를 바꾸면 사용하지 않아도 되는 조건문이 들어가 있음
    - `Movie` 객체의 `isDiscountable(LocalDateTime whenScreened, int sequence)` 메서드에서 각각의 condition에 따라 사용하지 않는 파라미터도 같이 넘겨주고 있음

### 5. 하지만 여전히 부족하다

#### 캡슐화 위반

- 속성을 감추고 있어도 인터페이스로 노출시키고 있는 구조
- 새로운 할인 정책이 추가되거나 제거된다면 이 메서드들에 의존하고 있는 모든 클라이언트가 영향을 받을 것

궁극적으로 캡슐화란 내부 데이터를 외부로 감추는 것 이상으로 **변하는 어떤 것이든 감추는 것**이다. 내부 구현의 변경으로 외부 객체가 영향을 받는다면 캡슐화를 위반한 것.

> 그래서 구현은 클라이언트 쪽에서 알도록 하라는 것도 관련이 있지 않을까? 여기서는 감추는 것보다는 아예 사용하지 않는 것.

### 6. 데이터 중심 설계의 문제점

- 131
  - 데이터 중심의 설계가 변경에 취약한 이유는 두 가지다.
    - 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
    - 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.
- 132
  - 올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다.
  - 데이터 중심 설계는 객체의 구현이 이미 결정된 상태에서 다른 객체와의 협력 방법을 고민하기 때문에 이미 구현된 객체의 인터페이스를 억지로 끼워맞출 수밖에 없다.
  - 인터페이스에 구현이 노출되어 있어 협력이 구현 세부사항에 종속이 되었고 그로 인해 객체의 내부 구현의 변경이 외부로 파장을 일으킬 수 밖에 없다.