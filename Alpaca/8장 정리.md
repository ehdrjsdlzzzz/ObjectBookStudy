# 8장 의존성 관리하기

협력에는 의존성이 필요하지만 과도한 의존성은 변경을 힘들게 한다. 객체지향 설계란 의존성을 관리하는 것이고 객체가 변활를 받아들일 수 있게 의존성을 정리하는 기술이다.

## 1. 의존성 이해하기

### 변경과 의존성

- 어떤 객체가 예전된 작업을 정상적으로 수행하기 위해 다른 객체를 필요로 하는 경우 두 객체 사이에 의존성이 존재한다고 말한다.

- 의존성은 방향성을 가지며 **항상 단방향**이다.
- 의존성의 대상의 형태는 다를 수 있다. 인스턴스 변수일 수도 있고, 상속받은 인터페이스나 부모 클래스일 수도 있으며 함수 인자일 수도 있다. 하지만 이들이 가지는 공통적인 특성은 자신이 의존하는 대상이 변경될 때 함께 변경될 수 있다는 점이다.

### 의존성 전이

A 객체가 B 객체에 의존할 때 만약 B 객체가 C 객체에 의존하고 있다면 A 객체는 C 객체에 의존한다고 말할 수 있다. 이를 의존성이 전이된다고 표현한다.

하지만 중요한 것은 실제로 변경이 일어날 시에 의존성으로 인해 A까지 변경의 여파가 미칠 지의 여부는 변경의 방향과 캡슐화의 정도에 따라 달라진다는 점이다.

### 런타임 의존성과 컴파일타임 의존성

유연하고 재사용 가능한 코드를 설계하기 위해서는 이 두 종류의 의존성을 서로 다르게 만들어야 한다. 때문에 어떤 **객체가 다른 객체와 협력할 때는 구체적인 클래스(구현 모습)에 의존하게 하지 말자**.

### 컨텍스트 독립성

구체 클래스에 의존하는 것은 클래스의 인스턴스가 어떤 문맥에서 사용될 것인지를 구체적으로 명시하는 것이기 때문에 다른 문맥에서 사용되기 어렵게 만든다. 때문에 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만을 한다면 다른 문맥에서의 재사용이 수월해진다.

### 의존성 해결하기

구체적인 컨텍스트를 모르기 때문에 런타임 시에는 컴파일타임 의존성이 구체적인 런타임 의존성으로 대체되어 컨텍스트를 제공해줘야 한다. 이를 **의존성 해결** 이라고 부르며 일반적으로 세 가지 방법이 있다.

- 객체의 생성 시점에 생성자를 통해 의존성 해결
  - 생성 시점에 해결하기 때문에 객체가 바로 기능을 수행할 준비가 된다.
- 객체 생성 후 setter 메서드를 통해 의존성 해결
  - 객체의 생성 직후에는 객체가 불완전하다는 단점이 있지만 의존하고 있는 대상을 변경할 수 있는 장점이 있다.
  - 따라서 더 좋은 방법은 생성자 방식과 setter 방식을 혼합하는 것이다.
- 메서드 실행 시 인자를 이용해 의존성 해결
  - 지속적으로 의존 관게를 맺을 필요 없이 메서드가 실행되는 동안에만 의존 관계가 있으면 될 때 사용

## 2. 유연한 설계

### 의존성과 결합도

의존성 자체는 협력의 필수적인 요소이며 **재사용성** 이 높게 설계된 의존성을 바람직하다고 한다. 이를 표현하는 단어가 **결합도** 이다. 바람직하지 못한 의존성은 다른 환경에서 재사용하기 위해 내부 구현을 변경하게 만든다.

### 지식이 결합을 낳는다

결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.  한 요소가 다른 요소에 대해 더 많이 알고 있을수록 두 요소는 강하게 결합된다.

지식의 양을 줄여 느슨한 결합을 만들자. 이를 달성할 수 있는 가장 효과적인 방법이 바로 '추상화'이다.

### 추상화에 의존하라

추상화를 사용하면 현재 다루고 있는 문제를 해결하는 데 불필요한 정보를 감출 수 있다. 따라서 알아야 하는 지식의 양을 줄여 결합도를 느슨하게 유지할 수 있다.

일반적으로 추상화와 결합도의 관점에서 의존 대상을 다음과 같이 구분하며 아래로 갈수록 클라이언트가 알아야 할 지식의 양이 적어져 결합도가 느슨해진다.

- 구체 클래스 의존성
- 추상 클래스 의존성
- 인터페이스 의존성

> 추상 클래스에서는 구현부가 아직 남아 있기 때문에 지식의 양이 인터페이스보다 많다.

### 명시적인 의존성

의존성은 명시적으로 퍼블릭 인터페이스를 통해 보여져야 한다. 이를 하지 않고 의존성을 숨긴다면 다음과 같은 문제를 야기한다.

- 의존성을 파악하기 위해 내부 구현을 직접 살펴봐야 한다.
- 더 큰 문제는 다른 컨텍스트에서 재사용하기 위해 내부 구현을 직접 변경해야 한다.

### new는 해롭다

클래스의 인스턴스를 생성하는 new를 잘못 사용하면 결합도가 극단적으로 높아진다. 이유는 크게 두 가지다.

- new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 하기에 구체 클래스에 의존하게 되고 때문에 결합도가 높아진다.
- new 연산자는 어떤 인자를 전달하여 생성하는 지에 대한 정보도 알아야 하기에 알아야 하는 정보의 양을 늘리게 된다.

때문에 클라이언트에서는 내부에서 new를 통해 의존성의 생성보다는 의존성을 외부에서 주입받아 그것을 그대로 사용하는 것이 좋다.

> 하지만 설계 시 기본적으로 의존하는 객체를 설정하고 싶을 경우에는 내부에서 생성하되 외부에서 주입받는 생성자를 만들어 이를 체이닝하는 형식으로 사용하자.

### 조합 가능한 행동

유연하고 재사용 가능한 설게는 객체가 어떻게 하는지를 장황하게 나열하지 않고도 객체들의 조합을 통해 무엇을 하는지를 표현하는 클래스들로 구성된다. **코드에 드러난 로직을 해석할 필요 없이 객체가 어떤 객체와 연결됐는지를 보는 것만으로도 객체의 행동을 쉽게 예상하고 이해할 수 있다.** 다시 말해 **선언적**으로 객체의 행동을 정의할 수 있는 것이다.