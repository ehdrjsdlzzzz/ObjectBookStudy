# 9장 유연한 설계

이번 장에서는 8장에서 다룬 의존성 관리 기법들을 '원칙'이라는 관점에서 정리한다. 반복이 될 수도 있지만 이름을 가진 설계 원칙을 통해 기법들을 정리하는 것은 장황하게 설명된 개념과 매커니즘을 또렷하게 정리할 수 있게 도와줄뿐만 아니라 설계를 논의할 때 사용할 수 있는 공통의 어휘를 익힌다는 점에서도 가치가 있을 것이다.

## 1. 개방-폐쇄 원칙

로버트 마틴이 확장 가능하고 변화에 유연하게 대응할 수 있는 설계를 만들기 위한 원칙 중 하나로 든 **개방-폐쇄 원칙(Open-Closed Principle, OCP)** 은 다음으로 요약된다.

소프트웨어 개체(클래스, 모듈, 함수)는

- 확장에 대해 열려 있다.
  - 요구사항의 변경 시에 **새로운 '동작'을 추가함**으로써 이를 기능을 확장할 수 있다.
- 수정에 대해 닫혀 있다.
  - **기존의 '코드'를 수정하지 않고도** 동작을 추가하거나 변경할 수 있다.

언뜻 말이 안 된다고 생각이 든다. 코드를 수정하지 않고 어떻게 동작을 추가할 수 있는가?

### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라

사실 이 원칙은 런타임 의존성과 컴파일타임 의존성에 관한 얘기다. 유연하고 재사용 가능한 설계에서는 두 의존성은 다른 구조를 가지게 된다. 두 시점의 의존성이 다르기 때문에 새로운 요구 사항이 왔을 때 컴파일 의존성은 그대로 놔두고, 즉 기존의 '코드'를 수정하지 않고도 런타임 의존성만 쉽게 변경, 즉 '동작'을 변경할 수 있다.

###추상화가 핵심이다

OCP의 핵심은 **추상화에 의존하는 것** 이다. 추상화 과정을 거치면 문맥이 바뀌더라도 **변하지 않는 부분만 남게 되고 문맥에 따라 변하는 부분은 생략**된다. 추상화를 사용하면 생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다.

>  결국 추상화는 차이가 있는 지점에서 인터페이스를 뽑아 내어 변하지 않는 부분으로 만들고 변하는 부분은 객체의 내부로 숨기는 '캡슐화' 과정일 것.

추상화 부분은 공통적이기 때문에 수정에 대해 닫혀 있게 되고 추상화를 통해 생략된 부분은 확장의 여지를 남긴다. 이것이 추상화가 OCP를 가능하게 만드는 이유다. 언제라도 생략된 부분은 문맥에 맞게 채워넣음으로써 새로운 문맥에 맞게 기능의 확장이 가능하다.

하지만 단순히 어떤 개념을 추상화했다고 해서 수정에 대해 닫혀 있는 설계를 만들 수 있는 것은 아니다. OCP에서 폐쇄를 가능하게 하는 것은 **의존성의 방향** 이다. **수정에 대한 영향을 최소화하기 위해서는 모든 요소가 추상화에 의존**해야 한다. 따라서 변경되지 않을 부분을 신중하게 결정하여 올바른 추상화를 선택해야 한다.

## 2. 생성 사용 분리

``` java
public class Movie {
    ...
    // 추상화에 의존하고 있는 것처럼 보임
    private DiscountPolicy discountPolicy;
    
    public Movie(String title, Duration runningTime, Money fee) {
        ...
        // 하지만 생성자에서 구체적인 문맥을 넣어주고 있음
        // 결국 Movie는 AmountDiscountPolicy에만 의존
        // 또한 Movie를 사용하는 클라이언트가 내부 구현까지 살펴봐야 함
        this.discountPolicy = new AmountDiscountPolicy(...);
    }
    
    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

추상화에 의존하고 있는 것처럼 보여도 실상은 그렇지 않는 경우가 있다. 위와 같은 코드에서는 동작을 바꾸기 위해 결국 내부의 코드를 변경하게 만든다.

결합도는 OCP를 따르는 구조 설계를 어렵게 하며 객체 생성에 대한 지식은 결합도를 높이는 경향이 있다. 하지만 객체는 분명 어딘가에서 생성이 되어야 하고 다만, 부적절한 곳에서 생성한다는 것이 문제다. **동일한 클래스 안에서는 객체 생성과 사용이라는 두 가지 이질적인 목적을 가진 코드가 공존하는 것을 피해야** 한다.

**가장 보편적인 방법은 객체 생성의 책임을 클라이언트로 옮기는 것**이다. 직관적으로도 어떤 컨텍스트를 사용할 지 결정하는 것은 클라이언트이기 때문에 타당하다.

그 밖에도 객체 생성 책임만을 갖는 FACTORY를 통해 생성하는 방법이 있다. 이러한 팩토리 객체는 도메인에 속하지 않는 '순수한 가공물' 객체이며 도메인 모델의 한계를 보완하여 좋은 설계를 이룰 수 있는 방법이다.

## 3. 의존성 주입

클라이언트나 팩토리처럼 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 **의존성 주입(Dependency Injection)**이라 한다. 의존성 주입에는 세 가지가 있다.

- 생성자 주입
- Setter 주입
- 메서드 주입

### 숨겨진 의존성은 나쁘다

숨겨진 의존성은 의존성의 대상을 설정하는 시점과 의존성이 해결되는 시점을 멀리 떨어뜨려 놓는다. 때문에 코드를 이해하고 디버깅하기 어렵게 하여 결국 수정을 어렵게 만든다.

## 4. 의존성 역전 원칙

```java
public class Movie {
    private AmountDiscountPolicy discountPolicy;
}
```

Movie는 구체 클래스에 의존하고 있어 변경에 취약하다. 왜냐하면 Movie는 가격 계산이라는 상위 수준의 개념을 구현하는 데 반해 AmouteDiscountPolicy는 특정 금액만큼의 할인이라는 하위 수준의 개념을 구현하고 있고 Movie가 여기에 의존하기 때문이다. 다시 말해 상위 수준 클래스가 하위 수준 클래스에 의존하는 것이다.

**객체 사이의 협력이 존재할 때 그 협력의 본질을 담고 있는 것은 상위 수준의 정책**이다. 상위 수준이 하위 수준에 의존하는 것은 두 가지 문제를 야기한다.

- 하위 수준의 변경이 상위 수준에 영향을 준다.
  - 의존성의 방향이 잘못되었다. 상위 수준에서 하위 수준으로 흘러야 자연스럽다.
- 재사용성이 떨어진다.
  - 하위 수준까지 재사용해야 하기 때문에 재사용하기가 어렵다.

이 같은 문제를 해결하기 위해서는 상위, 하위 수준의 클래스가 모두 추상화에 의존해야 한다. **구체 클래스는 의존성의 시작점이어야 한다. 의존성의 목적지가 돼서는 안 된다.**

> 의존성의 시작점이라는 말은 의존성 해결 시점을 말하는 것일까...?

이를 정리해보면,

1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

이를 **의존성 역전 원칙(Dependency Inversion Principle, DIP)** 라 하며 '역전'이라는 말은 의존성의 방향이 전통적인 절차형 프로그래밍과 반대 방향으로 나타나는 것을 표현한다.

## 5. 유연성에 대한 조언

### 유연한 설계는 유연성이 필요할 때만 옳다

유연성은 항상 복잡성을 수반하기 때문에 단순성과 명확성을 희생시킨다. 따라서 유연성은 코드를 읽는 사람들이 복잡함을 수용할 수 있을 때만 가치가 있다. 협업자 간의 커뮤니케이션을 통해 복잡성이 필요하다는 것을 설득해야 한다.

### 협력과 책임이 중요하다

결국 설계를 유연하게 만들기 위해서는 협력에 참여하는 객체가 다른 객체에게 어떤 메시지를 전송하는지가 중요하다. 먼저 역할, 책임, 협력에 초점을 맞추고 객체 생성에 대한 부담은 나중에 생각하자.



