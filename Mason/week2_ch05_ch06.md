# 5장. 책임 할당하기

#### 데이터보다 행동을 먼저 결정하라

- 133

  -  데이터 중심 설계로 인해 발생하는 문제점을 해결할 수 있는 가장 기본적인 방법은 데이터가 아닌 책임에 초점을 맞추는 것이다.
  - 어떤 객체에게 어떤 책임을 할당할지를 결정하기는 쉽지 않다. (책임 할당 과정은 트레이드오프 활동)
  - GRASP 패턴

- 134

  - 데이터보다 행동을 먼저 결정하라. 협력이라는 문맥 안에서 책임을 결정하라.

  - 데이터 중심의 설계 : 이 객체가 포함해야 하는 데이터는 무엇인가 > 데이터를 처리하는데 필요한 오퍼레이션은?
  - 책임 중심의 설계 : 이 객체가 수행해야 하는 책임은 무엇인가 > 책임을 수행하는 데 필요한 데이터는?

#### 협력이라는 문맥 안에서 책임을 결정하라

- 135
  - 객체의 입장에서 책임이 조금 어색해 보이더라도 협력에 적합하다면 그 책임은 좋은 것이다. (협력에 적합도가 중요)
  - 책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 한다.

#### 책임 주도 설계

- 136
  - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 피한다.
  - 시스템 책임을 더 작은 책임으로 분할한다.
  - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
  - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
  - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

> GRASP = General Responsibility Assignment Software Pattern(일반적인 책임 할당을 위한 소프트웨어 패턴)

- 설계과정은 도메인 안에 존재하는 개념들을 정리하는 것

#### 도메인 개념에서 출발하기

- 138
  - 도메인 개념을 정리하는 데 너무 많은 시간을 들이지 말고 빠르게 설계와 구현을 진행하라.
- 메시지를 전송할 객체는 무엇을 원하는가? 메시지를 수신할 적잡한 객체는 누구인가?
- 139
  - 객체에게 책임을 할당 할 때 그 객체가 수행할 정보를 `알고` 있는지가 중요하다. 객체가 책임을 수행하기 위해서 정보를 알고 있따고 해서 __그 정보를 `저장`__ 하고 있을 필요는 없다. -> 객체가 정보를 제공할 수 있는 다른 객체를 알고 있거나 필요한 정보를 계산해서 제공할 수도 있는 것. (저장하고 있을 필요가 없다는 건 매우 중요!)
- GRASP
  - INFORMATION EXPERT PATTERN
    - 메시지를 처리하기 위해 정보를 가장 잘 알고 있는 객체가, 자율성을 갖고.
  - LOW COUPLING PATTERN
    - 의존성을 낮추고 변화의 영향을 줄이며 재사용을 증가시킬 수 있는지?
  - HIGH COHESION PATTERN
    - 어떻게 복잡성을 관리할 수 있는 수준으로 유지할 것인가?
  - CREATOR PATTERN
    - 객체 A를 생성해야 할 때 어떤 객체가 객체에게 생성 책임을 할당해야 하는가?
      - B가 A 객체를 포함하거나 참조한다.
      - B가 A 객체를 기록한다.
      - B가 A 객체를 긴밀하게 사용한다.
      - B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다(이 경우 B는 A에 대한 정보 전문가다)
  - POLYMORPHISM PATTERN
  - PROTECTED VARIATIONS PATTERN
- 140
  - Screening은 가격을 계산하는 데 필요한 정보를 모르기 때문에 외부의 객체에게 도움을 요청해서 가격을 얻어야 한다고 했는데, 메시지를 처리하기 위해 Screening이 그 정보를 알아야할지 외부 객체에 도움을 요청해서 얻어야할지를 무엇을 근거로 판단해야하는가? -> 142, 143 근거 : 응집도와 결합도. 협력하는 방법의 차이
- 145
  - 협력과 책임이 제대로 동작하는지 확인할 수 있는 유일한 방법은 코드를 작성하고 실행해 보는 것 뿐이다.
- 152

  - 변경의 이유에 따라 클래스를 분리해야 한다.

  - 변경의 이유를 파악할 수 있는 첫 번째 방법 : 인스턴스 변수가 초기화 되는 시점을 볼 것. -> __응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다.__
  - 두 번째 방법 : __메서드들이 인스턴스 변수를 사용하는 방식을 살펴볼 것.__ (모든 메서드가 객체의 모든 속성을 사용하는가?)
- 168

  - 긴 메서드의 다양한 측면에서 코드의 유지보수에 부정적인 영향을 미친다.
    - 어떤 일을 수행하는지 한눈에 파악하기 어렵다.
    - 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다.
    - 메서드 내부의 일부 로직만 수정하더라도 메서드의 나머지 부분에서 버그가 발생활 확률이 높음.
    - 로직의 일부만 재사용하는 것이 불가능하다.
    - 코드 중복을 초래하기 쉽다.
  - __응집도가 낮은 메서드는 로직의 흐름을 이해하기 위해 주석이 필요한 경우가 대부분이다.__ 메서드가 명령문들의 그룹으로 구성되고 각 그룹에 주석을 달아야 할 필요가 있다면 그 메서드의 응집도는 낮은 것이다. 주석을 추가하는 대신 메서드를 작게 분해해서 각 메서드의 응집도를 높여라.

# 6장. 메시지와 인터페이스

- 179
  - 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션(operation)이라고 부른다. 오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화다.
  - 퍼블릭 인터페이스와 메시지의 관점에서 보면 '메서드 호출'보다는 '오퍼레이션 호출'이라는 용어를 사용하는 것이 더 적절하다.
  - 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합쳐 시그니쳐(Signature)라고 부른다.
- 182
  - 디미터 법칙 : 객체 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라. > 결합도를 효과적으로 낮출 수 있다.
  - 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍
  - 클래스 내부의 메서드가 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍
    - self 객체
    - self의 속성
    - self의 속성인 컬렉션의 요소
    - 메서드의 매개변수
    - 메서드 내에서 생성된 지역 객체

- 185

  - 디미터 법칙을 위반하는 코드의 전형적인 모습 (기차 충돌.train wreck)

    ```swift
    screening.getMovie().getDiscountCOnditions()
    ```

#### 묻지 말고 시켜라

- 188
  - 메서드 네이밍 : '어떻게'가 아니라 '무엇'을 하는지를 드러내라. (내부 구현을 드러내지 말 것)
  - Intention Revealing Selector
- 190
  
- 클라이언트 관점에서 동일한 작업을 수행하는 메서드들을 하나의 타입 계층으로 묶을 수 있다면 다양한 타입의 객체가 참여할 수 있는 유연한 협력을 얻게 된다.
  
- 198 (Rx하면서 오퍼레이터에 대한 분류에 대해 깨달은 부분)

  - 법칙에는 예외가 없지만 원칙에는 예외가 넘친다.

  - 트레이드 오프 고려 사항

    - __디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.__

      - 아래 코드는 디미터 법칙을 위반한 것이 아니다. 결과적으로 같은 클래스의 인스턴스를 반환한다. (IntStream의 인스턴스를 또 다른 IntStream의 인스턴스로 변환한다.)
      - 디미터 법칙은 결합도와 관련된 것이고, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다.

      ```swift
      IntStream.of(1,2,3,4).filter { $0 % 2 ==0 }.distinct().count()
      ```

- 202
  - 로버트 마틴<클린코드> : 디미터 법칙의 위반 여부는 묻는 대상이 객체인지, 자료 구조인지에 달려 있다고 설명. 자료구조 라면 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없다.
  - 소프트웨어 설계에 법칙이란 존재하지 않는다는 것이다. 원칙을 맹신하지 말고 원칙이 적절한 상황과 부적절한 상황을 판단할 수 있는 안목을 길러라. __설계는 트레이드오프의 산물이다.__ 소프트웨어 설계에 존재하는 몇 안 되는 법칙 중 하나는 "경우에 따라 다르다"라는 사실을 명심할 것.

#### 명령-쿼리 분리 원칙

- 루틴(routine), 프로시저(procedure), 함수(function)
  - 프로시저는 부수효과를 발생시킬 수 있지만, 값을 반환할 수 없다. 함수는 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.
  - 프로시저 looks like Command, 부수효과 looks like Query

- 이 부분은 Swift에서 Collection 타입을 보면 좀 다르다는 걸 알 수 있음.

- 명령과 쿼리를 나누면 얻게되는 장점?

  - 예제의 설명을 잘보여줌 p.205
  - 명령과 쿼리를 뒤섞으면 실행 결과를 예측하기가 어려워질 수 있다.

- 213

  - 참조 투명성을 만족하면?
    - 모든 함수를 이미 알고 있는 하나의 결과값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.
    - 모든 곳에서 함수의 결과값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과가 달라지지 않는다.

  - 객체지향 패러다임이 객체의 상태 변경이라는 부수효과를 기반으로 하기 때문에 참조 투명성은 예외에 가깝다. 하지만 명령-쿼리 분리 원칙을 사용하면 부수효과를 가지는 명령으로부터 부수효과를 가지지 않는 쿼리를 명백하게 분리함으로써 제한적이나마 참조 투명성의 혜택을 누릴 수 있게 해준다.

#### 명령형 프로그래밍과 함수형 프로그래밍

> 부수효과를 기반으로 하는 프로그래밍 방식을 __명령형 프로그래밍(imperative programming)__ 이라고 한다. 상태를 변경시키는 연산들을 적절한 순서대로 나열함으로써 프로그램을 작성. 대부분의 객체지향 프로그래밍 언어들은 메시지에 의한 객체의 상태 변경에 집중하기 때문에 명령형 프로그래밍 언어로 분류된다.

> __함수형 프로그래밍(functional programming)__은 부수효과가 수학적인 함수에 기반한다. 함수형 프로그래밍에서는 참조 투명성의 장점을 극대화할 수 있으며 명령형 프로그래밍에 비해 프로그램의 실행 결과를 예측하기 쉽다. 또한 하드웨어의 발달로 병렬 처리가 중요해진 최근에는 함수형 프로그래밍의 인기가 상승하고 있다.





```swift
class A {
 
  func functionA(parameter: P) {
		paramter.doSomething()
  }
 
  func functionB(parameter: P) {
    let value = paramter.getOb()
    value
		//let valueToUse = newOb.getValue()
    // 이거슨 let valueToUse = paramter.getOb().getValue() 
  }
}
```







----

### Discussion

- 이해 확인
  
- POLYMORPHISM PATTERN은 다형성을 이용한거기 때문에 서브클래싱이나 인터페이스와는 상관없고 공통된 사항을 묶어주는거로만 생각하면되고, 거기서 더 나아가서 인터페이스(프로토콜)로 폴리모피즘 패턴을 구현하는게 PROTECTED VARIATION 패턴이라고 보면될까요? 159쪽 잘 모르겠음.
  
- 디미터 법칙에서 메서드의 매개변수로 넘어온 것 애한테도 메시지를 전송하도록 프로그래밍 할 수 있다고 했는데 아래와 같은 경우는? 184페이지네 나온 내용을 보면 A는 P의 내부에 대한 어떤 정보도 알지 못한다고 한다면 아래와 같이 파라미터로 받은 객체에서의 메서드로 인한 객체의 메서드를 호출하면 안되지 않을까

  ```swift
  class A {
    // 메소드의 인자로 넘어온 매개변수
    func ok(parameter: P) {
  		paramter.doSomething()
    }
    
    // 인자로 받은 객체에서의 호출
    func notOk(parameter: P) {
      //
      let instance: T = paramter.getInstance()
      let value = instance.getValue()
      // ... 생략
    }
  }
  ```

- 함수형 프로그래밍에 대한 얘기를 조금 더 해줬으면 하는게 좀 아쉽...