# 7장. 객체 분해

#### 약간 이론적인 이야기 조금

- 216

  - 인지과부하(문제 해결에 필요한 요수의 수가 단기 기억의 용량을 초과하는 순간 문제 해결 능력은 급격하게 떨어진다.)

  - 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업 > __추상화__
  - 큰 문제를 해결 가능한 작은 문제로 나누는 작업 > __분해(decomposition)__
  - 매직넘버 7

- 218

  - __프로시저 추상화__ : 무엇을 해야하는지, __데이터 추상화__ : 무엇을 알아야 하는지를 추상화.
  - 프로시저 추상화
    1. 기능 분해(functional decomposition) = 알고리즘 분해(algorithmic decomposition)
  - 데이터 추상화
    - 두 가지 중 하나 선택
      1. 데이터를 중심으로 __타입__을 추상화 type abstraction > __추상 데이터타입__
      2. 데이터를 중심으로 __프로시저__를 추상화 procedure abstraction > __객체지향__
    - '역할과 책임을 수행하는 객체' > 객체지향 패러다임이 이용하는 추상화

- 219

  - 기능 분해에서 추상화의 단위는 __프로시저__, 시스템은 프로시저를 단위로 분해.
    - 프로시저란? 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법이다.

- 226

  - 하향식 기능 분해의 문제점
    - 시스템은 하나의 메인 함수로 구성돼 있지 않다.
      - 시스템은 여러 개의 정상(top)으로 구성된다.
    - 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.
    - 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.
      - 초기 단계부터 입력 방법과 출력 양식을 함께 고민하도록 강요한다. (sample: 급여관리시스템 예제 중)
    - 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.
    - 데이터 형식이 변경 될경우 파급효과를 예측할 수 없다.
      - 데이터 변경이 일어날 경우 어떤 함수가 영향을 받을지 예상하기 어렵다.
      - 개별 함수의 입장에서 사용하는 데이터를 파악하는 것은 어렵지 않지만, 어떤 데이터가 어떤 함수에 존재하고 의존하는지를 파악하는 것은 어려운 일이다. 모든 함수를 열어 데이터를 사용하고 있는지를 확인해봐야 하기 때문이다.
        - 코드 안에서 텍스트를 검색하는 단순한 문제가 아니다. 의존성과 결합도의 문제다

- 230

  - 객체지향은 함수 간의 호출 순서가 아니라 객체 사이의 논리적인 관계를 중심으로 설계를 이끌어 나간다. 결과적으로 전체적인 시스템은 어떤 한 구성요소로 제어가 집중되지 않고 여러 객체들 사이로 제어 주체가 분산된다.
  - 상위 함수가 가용하는 문맥안에서만 의미를 갖도록 하는 함수는 굉장히 재사용성이 낮다.

- 234

  - 의존성 관리의 핵심: 데이터 변경으로 인한 영향을 최소화 하기 위해 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리할 줄 알아야 한다.

- 235

  - 정보은닉은 시스템을 모듈 단위로 분해하기 위한 기본 원리로 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야한다는 것이 핵심이다.

- 240

  - 모듈의 가장 큰 단점은 인스턴스의 개념을 제공하지 않는다는 점이다. 모듈안의 개별적인 정보에 대한 인스턴스 추상화가 매커니즘이 필요하다 이를 만족시키기 위해 등장한 개념이 __추상 데이터 타입__

- 250

  - 클래스가 추상 데이터 타입의 개념을 따르는지 확인할 수 있는 가장 간단한 방법은 클래스 내부에 인스턴스의 타입을 표현하는 변수가 있는지를 살펴보는 것이다. 인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명식적으로 구분하는 방식은 객체지향을 위반하는 것으로 간주한다.
  - 객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체한다.
    - 클라이언트가 객체의 타입을 확인한 후 적절한 메서드를 찾아서 호출하는 것이 아니라 객체가 메시지를 처리할 적절한 메서드를 선택한다.

- 251

  - OCP 개방-폐쇄 원칙 : 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성

  - 설계가 기준이 되야한다. 

    - 설계에 요구되는 변경의 압력이 '타입 추가'에 관한 것인지, '오퍼레이션 추가'에 관한 것인지에 따라 달라진다.
    - 타입추가의 압력이 더 높은 경우 -> 객체지향
    - 오퍼레이션 추가 -> 추상 데이터 타입

    

# 8장. 의존성 관리하기

- 253
  - 어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재하게 된다.
  - 실행시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에는 의존 대상 객체가 반드시 존재해야 한다.
  - 구현 시점 : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.
- 256
  - __의존성 전이(transitive dependency)__
    - A -> B -> C에서 A가 자연스레 C에 대한 간접 의존성이 생김
  - 직접 의존성과 간접 의존성

#### 런타임 의존성과 컴파일타임 의존성

- 257
  - 런타임 : 애플리케이션 실행되는 시점
  - 컴파일 타임 : 작성된 코드를 컴파일 하는 시점을 말하거나 문맥적으로 코드 자체를 가리키기도 함.
    - 컴파일타임 의존성을 말할 땐 문맥적으로 코드 자체를 가리킨다.
  - 런타임의 주인공은 객체, 코드 관점에서 주인공은 클래스. 즉 컴파일타임의 의존성이 다루는 주제는 클래스 사이의 의존성.

### 컨텍스트 독립성

- 260
  - 유연한 설계를 위해 컴파일타임 의존성과 런타임 의존성이 달라야 한다.
  - 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다. > __컨텍스트 독립성__ 
  - 어떻게 컨텍스트 독립적인데 런타임에 실행되는 컨텍스트에 적절한 객체들과 협력할 수 있지?
  - p.261부터 나오는 __의존성 해결하기__를 읽어보자.

### 의존성 해결하기

- 컴파일타임의 의존성을 실행 컨텍스트에 맞춰 적절한 런타임 의존성으로 교체하는 것
  - 세가지 방법
    1. 객체를 생성하는 시점에 생성자를 통해 의존성 해결
    2. 객체 생성 후 setter 메서드를 통해 의존성 해결
    3. 메서드 실행 시 인자를 이용해 의존성 해결

- 265
  - 바람직한 의존성이란 __재사용__과 관련이 있다. > 결국 컨텍스트 독립적인 의존성이 바람직함.
  - 객체가 다른 의존성 객체에 대해 많이 안다? 결합도가 높아진다...

### 추상화에 의존하라

- 271
  - 의존성은 명시적으로 표현돼야 한다.
  - 의존성을 구현 내부에 숨겨두지 마라.
  - 유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계다.
  - 인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리하는 것.
- 274
  - 가끔은 의존성있는 객체의 인스턴스를 내부에서 직접 생성해도 괜찮다.
- 276
  - 표준 클래스에 대한 의존은 해롭지 않다.



----

### Discussion

- 추상 데이터 타입과 클래스의 다른 점
  