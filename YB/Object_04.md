# 설계 품질과 트레이드 오프

- p97

  - 객체지향 설계 = 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조

  - 합리적인 비용 안에서 변경을 수용할 수 있는 구조를 만드는것이 훌륭한 설계이다.

    - (== 적절한 비용 안에서 쉽게 변경할 수 있는 설계는 응집도가 높고, 서로 느슨하게 결합돼 있는 요소로 구성된다.)

  - 객체의 상태가 아니라 객체의 행동에 초점을 맞추는 것이 중요한 원칙이다.

    - 이유는 변경과 관련이 있다

    

    - P109

      - 객체지향 설계의 가장 중요한 원리는 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화 하는것이다
        - 
      - 객체 내부에 변경될 수 있는 어떠한 것이라도 캡슐화 해야한다. -> 유지보수성이 목표.

    - p110

      - 응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다.
        - 모듈이 하나의 목적을 추구한다면 높은 응집도를 갖고, 모듈이 다양한 목적을 추구한다면 낮은 응집도를 갖는다.
      - 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다.

      - 높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계가 좋은 설계이다.
        - 하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 응집도가 높은 것이고 모듈의 일부만 변경된다면 응집도가 낮은것이다.(하나의 모듈,객체는 하나의 목적?을 갖도록 하는것이 올바른것인가)

    - p112

      - 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있다.
        - protocol Shakable vs Extension UIView...의 경험

    - p113

      - 캡슐화의 정도가 객체의 응집도와 결합도를 결정한다
        - 데이터 중심의 설계가 가진 문제점(캡슐화 위반, 높은 결합도, 낮은 응집도) -> 앞장에서도 말하지만 역할?, 메시지를 우선적으로 고려

    - p117

      - 요구사항 변경을 수용하기 위해 하나 이상의 클래스를 수정해야하는 것은 설계의 응집도가 낮다는 것이다.
        - 위에서 얘기한 바 대로 하나의 모듈에 다른 목적을 추구하는 로직이 많다면, 요구사항 변경에 따라 여러 클래스를 수정해야 하는 상황이 발생 -> 응집도가 낮음
        - `단일 원칙 책임` = 클래스는   단 한가지의 변경 이유만 가져야 한다

    - p119

      - ```swift
        class Rectangle { 
        	func enlarge(multiple: Int) {
            right *= multiple
            bottom *= multiple
          }
        }
        
        // Rectangle을 확대하기 위해서 내부 상태를 알 수 없다. 
        // --> 객체가 자기 스스로를 책임진다.
        ```

    - p128

      - 캡슐화란 어떠한 변할 수 있는 것이라도 감추는 것이다.
      - 외부의 객체가 영향을 받는다면 캡슐화를 위반한 것이다.

    - p131

      - 데이터 중심 설계가 변경에 취약한 이유

        - 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요받는다.

        - 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

          (계속 반복되지만, 전송할 메시지를 설계하고, 그 메시지를 처리하는데 적임자를 찾는 과정을 반복하여야한다)