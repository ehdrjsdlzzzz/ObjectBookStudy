# 의존성 관리하기

### 의존성 이해하기

- 254

    - 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 갖는다
        - 실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
        - 구현 시점 : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.
        - 한 객체에서 다른 객체를 필요로 하는 경우 의존성이 존재한다고 말한다
        - 의존성은 단방향이다. (변경이 한쪽에만 영향을 끼침)

- p256

    - 의존성은 UML에서 정의하는 모든 관계가 가지는 공통적인 특성으로 바라봐야 한다

        - > 공통적인 특성이란 어떤것? == 함께 변경이 일어나는 특성?

- p257

    - 의존성이 전이 될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라진다.

    - 컴파일타임 의존성이라는 용어가 중요하게 생각하는 것은 시간이 아니라 우리가 작성한 코드의 구조이기 때문이다.

        - > 우리가 작성한 코드의 구조를 중요하게 생각하는것 인가요?

- p258

    - 객체지향 애플리케이션에서 런타임의 주인공은 객체다. 따라서 런타임 의존성이 다루는 주제는 객체 사이의 이존성이다.
    - 코드 관점에서 주인공은 클래스다. 클래스 사이의 의존성이다.

- p260

    - 컴파일 타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용 가능해진다.
    - 클래스가 사용될 특정한 문맥에 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다. 이를 `컨텍스트 독립성` 이라고 부른다.

- p261

    - 컴파일 타임 의존성을 실행 컨특스트에 맞는 적절한 런타임 의존성으로 교체하는것은 의존성 해결이라고 부른다
    - 의존성 해결하기
        - 객체를 생성하는 시점에 생성자를 통해 의존성 해결
        - 객체 생성 후 setter 메서드를 통해 의존성 해결
        - 메서드 실행 시 인자를 이용해 의존성 해결

- p265
    - 의존성은 협력을 위해 반드시 필요한 것이다.
    - 바람직한 의존성은 재사용성과 관련이 있다.
        - 컨텍스트에 독립적인 의존성은 바람직한 의존성이고 특정한 컨텍스트에 강하게 결합된 의존성은 바람직하지 않은 의존성이다.
- p267
    - 결합도를 느슨하게 만들기 위해서는 협력하는 대상에 대해 필요한 정보 외에는 최대한 감추는 것이 중요하다.
        - 추상화(특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법)를 통하여

- p271

    - 의존성은 명시적으로 표현돼야 한다.

    - 의존성을 구현 내부에 숨겨두지 마라.

    - 유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계다.

    - new는 해롭다

        - > 생성하는 타입에 대한 의존성은 물론이고 생성하는데 필요한 추가적인 타입들 또한 의존성이 추가되는것을 고려해야함

- p273

    - 2번째 문단
    - 인스턴스를 생성하는 로직과 인스턴스를 사용하는 로직을 분리

- p274

    - 사용과 생성의 책임을 분리하고, 의존성을 생성자에 명시적으로 드러내고, 구체 클래스가 아닌 추상클래스에 의존하게 함으로써 설계를 유연하게 만들 수 있다.

    - 클래스 안에서 객체의 인스턴스를 직접 생성하는 방식이 유용한 경우도 있다.

        - > 생성자 오버로딩으로 활용

- p279

    - 단지 원하는 기능을 구현한 DiscountPolicy의 자식 클래스를 추가하고 이 클래스의 인스턴스를 Movie에 전달하기만 하면 된다

        - > p277 에서 null처리 == 사용의 책임만 갖고있으면 됨
            >
            > 할인 없음, 중복적용 사례에서는 생성 책임 측면에서 타입을 추가하며, 결합도를 낮춤? -> 재사용 가능한 설계

